# my-notes
## This is the solution of task 2 in ASAC
My name is **Malek** Hamdan I'm fresh graduate.
I studied **software engineering** in Al **Balqa** Applied University.
I worked as a customer employee service of *6 months* in Ministry of Digital Economy.
#### I have familiarity with : ðŸ‘‡ðŸ‘‡
1. HTML
2. CSS
3. C++
4. Java 
### Take it as an approach in your life ðŸ‘‡ðŸ‘‡
```c++
if(You.sad()==true){
    sad().stop();
    beAwesome();
}
 ```
***
# The key points that every developer must master :ðŸ‘‡ðŸ‘¨â€ðŸ’»

## 1. Conceiving The Purpose of Software.
> When you are making decisions about software, you should guide yourself by always keeping this in mind: How we can help? You can even prioritize feature requests this way.

## 2. The Goals of Software Design.
> When software is hard to create or modify, developers spend most of their time focusing on making things â€œjust work,â€ and less time focusing on helping users.So there are two key points here: Your design should be easy for you and helpful for others.

## 3. (Mis)understanding.
> Actually, one of the best ways to improve your design skills is to be sure that you fully understand the systems and tools you are working with. Bad developers donâ€™t understand what they are doing, and good developers do. It really is that simple.

## 4. Simplicity.
> Programming is the act of reducing complexity to simplicity. A â€œbad developerâ€ is just somebody who fails to reduce complexity. A â€œgood developerâ€ is doing everything in their power to make the code as simple as possible for other programmers. A good developer creates things that are easy to understand so that itâ€™s really easy to shake out all the bugs.
The question is: â€œHow simple do you have to be?â€
*Here is your answer: **Stupid, dumb simple**.*

## 5. Complexity
> The source of many software failures is complexity. You start out with a simple project that can be completed in one month. Then you add complexity, and the task will take up to three months. Then you start to add features that fulfill some other purpose. Things get very complex because you expand your software purpose for no reason. The tasks will take six months.There are many factors that will increase complexity but those are the most popular ones. Aside from everything, there is only one rule that you should follow:
Your **main purpose** is to ***control complexity, not to create it.***

## 6. Maintenance
> Maintenance is one of the most important things in software development. Unfortunately, developers usually ignore how important it is. Quick coding and fast shipping look more important than code maintenance. This is the point where they make a mistakeâ€Šâ€”â€Šignorance of future code maintenance.The ***one rule*** that you should follow about maintenance is:
***It is more important to reduce the effort of maintenance than it is to reduce the effort of implementation.***

## 7. Consistency
> Consistency is a big part of simplicity. If you do something one way in one place, do it that way in every place. For example, if you name a variable thisIsVariable, then all of your variables should be named that way.
Code that isnâ€™t consistent becomes harder to understand.

## 8. Prioritizing
> When you prioritize your work, you should follow this rule:
The changes that will bring you a lot of value and require little effort are better than those that will bring little value and require a lot of effort.

## 9. Solving Problems
> The first step is understanding. Know exactly what is being asked. Most hard problems are hard because you donâ€™t understand them. Write down your problem and try to explain it to someone else.
The second step is planning. Donâ€™t take action. Sleep on it. Give your brain some time to analyze the problem and process the information but donâ€™t spend too much time on planning.
Think before acting.
The third step is dividing. Donâ€™t try to solve one big problem. When you look at the problem as a whole, it can scare you. Divide it into smaller tasks and solve each sub-problem one by one. Once you solve each sub-problem, you connect the dots.

## 10. Good enough is fine
> â€œPerfect is the enemy of good.â€
>Whether creating a new project or adding a feature to existing system developers tend to plan everything out in detail from the beginning.
They want the first version to be perfect. They donâ€™t focus on the problem they will solve and how their software will help people.
***The incremental design should be your guide.***

## 11. Predictions
> When faced with the fact that their code will change in the future, some developers attempt to solve the problem by designing a solution so generic that (they believe) it will accommodate to every possible future situation. ***Donâ€™t predict to future. Be only as generic as you know you need to be right now.***

## 12. Assumptions
>â€œAn **assumption** is something that you accept as true or suppose to be true, although you have no conclusive proof.â€
One of the great killers of a software project is assumptions.**Code should be designed based on what you know now, not on what you think will happen in the future.**

## 13. Stop Reinventing
> The only times itâ€™s okay to reinvent the wheel is when any of the following are true:
> - You need something that doesnâ€™t exist yet.
> - All of the existing â€œwheelsâ€ are bad technologies or incapable of handling your needs.
> - The existing â€œwheelsâ€ arenâ€™t being properly maintained.
Simple rule:
**Donâ€™t reinvent the wheel.**

## 14. Resistance
>As a developer, your first reaction to changing requests should be â€œNOâ€™â€™.
Always resist adding more code, more features until you are convinced that they are required and there is a need to implement them. Because unnecessary changes will increase defects in your software.

# 15. Automation
>Donâ€™t spend your time on repetitive tasks. Set them up and forget about them. They can work while you are sleeping. When you realize that you are doing something again and again, just remember this rule:
If you can automate it, automate it.

## 16. Code measurement
>*Measuring programming progress by lines of code is like measuring aircraft building progress by weight.
â€” Bill Gates*
The **optimum code** is a small bunch of code that is easy to understand, easy to read.

## 17. Productivity
>Your main goal should be keeping your code base as small as possible.
*â€œOne of my most productive days was throwing away 1000 lines of code.â€â€Šâ€”â€ŠKen Thompson*

## 18. Testing
>You should add logging in a very early stage. This will help you to find the problem easily and save your time.
Untested code is the code that doesnâ€™t work.

## 19. (Under)Estimation

>Developersâ€™ estimation sucks.
Usually, they underestimate things rather than overestimate them. They underestimate the time and effort required to develop a small amount of code or a feature. In the end, this underestimation leads to missing deadlines.
The solution: Break the big thing into smaller things. The smaller it is, the easier it is to estimate. Youâ€™re probably still going to get it wrong, but youâ€™ll be a lot less wrong than if you estimated a big project.
Remember:
**Everything takes longer than you think.**

## 20 . Running Away From Rewriting
>Rewriting code is often a developer delusion, not the solution in most cases.
Here is simple advice for you:
**Refactoring should be the first option.**

## 21. Documentation and Commenting
>**Write a comment to explain â€œWHYâ€, not to explain â€œWHATâ€.**
Another thing is documenting. It is important to have documentation to explain your softwareâ€™s architecture and every module and components. This is required to see the high-level picture of your software.

## 22. Picking Technologies (Tools, Libraries, etc.)
>Donâ€™t depend on external technologies. But when you have to do so, try to reduce your dependency on them as much as you can.
## 23. Self-Development
>Keep learning. Try out different programming languages and tools, read books on software development. They will give you another perspective. Every day small improvements will make a real difference in your knowledge and skills.
Be open-minded. Donâ€™t be obsessive about one technology. Use the required technology to solve a specific problem. Donâ€™t be in the unnecessary discussion like Microsoft vs Linux :)
Know that every specific problem has its own specific solution.

## 24. Donâ€™t be a hero
>**Donâ€™t be obsessive. Know when to quit. Donâ€™t hesitate to ask for help.**

## 25. Donâ€™t Ask Questionsâ€¦ Ask For Help


### My picture  ðŸ‘‡ðŸ‘‡
![](https://avatars.githubusercontent.com/u/62914608?s=400&u=e121693e8db19ce693b78b875d3b6c97a0561333&v=4)
#### My GitHub account : [GitHub](https://github.com/MalekJamal) 
